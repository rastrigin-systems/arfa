// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateSession = `-- name: CreateSession :one

INSERT INTO sessions (
    employee_id,
    token_hash,
    ip_address,
    user_agent,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, employee_id, token_hash, ip_address, user_agent, expires_at, created_at
`

type CreateSessionParams struct {
	EmployeeID uuid.UUID        `json:"employee_id"`
	TokenHash  string           `json:"token_hash"`
	IpAddress  *string          `json:"ip_address"`
	UserAgent  *string          `json:"user_agent"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
}

// Authentication and session queries
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, CreateSession,
		arg.EmployeeID,
		arg.TokenHash,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.TokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteEmployeeSessions = `-- name: DeleteEmployeeSessions :exec
DELETE FROM sessions
WHERE employee_id = $1
`

func (q *Queries) DeleteEmployeeSessions(ctx context.Context, employeeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteEmployeeSessions, employeeID)
	return err
}

const DeleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, DeleteExpiredSessions)
	return err
}

const DeleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE token_hash = $1
`

func (q *Queries) DeleteSession(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, DeleteSession, tokenHash)
	return err
}

const GetSession = `-- name: GetSession :one
SELECT id, employee_id, token_hash, ip_address, user_agent, expires_at, created_at FROM sessions
WHERE token_hash = $1 AND expires_at > NOW()
`

func (q *Queries) GetSession(ctx context.Context, tokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, GetSession, tokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.TokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const GetSessionWithEmployee = `-- name: GetSessionWithEmployee :one
SELECT
    s.id,
    s.employee_id,
    s.token_hash,
    s.ip_address,
    s.user_agent,
    s.expires_at,
    s.created_at,
    e.org_id,
    e.team_id,
    e.role_id,
    e.email,
    e.full_name,
    e.status,
    e.preferences,
    e.last_login_at,
    e.created_at as employee_created_at,
    e.updated_at as employee_updated_at
FROM sessions s
JOIN employees e ON s.employee_id = e.id
WHERE s.token_hash = $1
  AND s.expires_at > NOW()
  AND e.status = 'active'
`

type GetSessionWithEmployeeRow struct {
	ID                uuid.UUID        `json:"id"`
	EmployeeID        uuid.UUID        `json:"employee_id"`
	TokenHash         string           `json:"token_hash"`
	IpAddress         *string          `json:"ip_address"`
	UserAgent         *string          `json:"user_agent"`
	ExpiresAt         pgtype.Timestamp `json:"expires_at"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	OrgID             uuid.UUID        `json:"org_id"`
	TeamID            pgtype.UUID      `json:"team_id"`
	RoleID            uuid.UUID        `json:"role_id"`
	Email             string           `json:"email"`
	FullName          string           `json:"full_name"`
	Status            string           `json:"status"`
	Preferences       json.RawMessage  `json:"preferences"`
	LastLoginAt       pgtype.Timestamp `json:"last_login_at"`
	EmployeeCreatedAt pgtype.Timestamp `json:"employee_created_at"`
	EmployeeUpdatedAt pgtype.Timestamp `json:"employee_updated_at"`
}

func (q *Queries) GetSessionWithEmployee(ctx context.Context, tokenHash string) (GetSessionWithEmployeeRow, error) {
	row := q.db.QueryRow(ctx, GetSessionWithEmployee, tokenHash)
	var i GetSessionWithEmployeeRow
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.TokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.Status,
		&i.Preferences,
		&i.LastLoginAt,
		&i.EmployeeCreatedAt,
		&i.EmployeeUpdatedAt,
	)
	return i, err
}
