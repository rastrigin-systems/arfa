// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage_records.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateUsageRecord = `-- name: CreateUsageRecord :one
INSERT INTO usage_records (
    org_id,
    employee_id,
    agent_config_id,
    resource_type,
    quantity,
    cost_usd,
    period_start,
    period_end,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, org_id, employee_id, agent_config_id, resource_type, quantity, cost_usd, period_start, period_end, metadata, token_source, created_at
`

type CreateUsageRecordParams struct {
	OrgID         uuid.UUID        `json:"org_id"`
	EmployeeID    pgtype.UUID      `json:"employee_id"`
	AgentConfigID pgtype.UUID      `json:"agent_config_id"`
	ResourceType  string           `json:"resource_type"`
	Quantity      int64            `json:"quantity"`
	CostUsd       pgtype.Numeric   `json:"cost_usd"`
	PeriodStart   pgtype.Timestamp `json:"period_start"`
	PeriodEnd     pgtype.Timestamp `json:"period_end"`
	Metadata      json.RawMessage  `json:"metadata"`
}

func (q *Queries) CreateUsageRecord(ctx context.Context, arg CreateUsageRecordParams) (UsageRecord, error) {
	row := q.db.QueryRow(ctx, CreateUsageRecord,
		arg.OrgID,
		arg.EmployeeID,
		arg.AgentConfigID,
		arg.ResourceType,
		arg.Quantity,
		arg.CostUsd,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Metadata,
	)
	var i UsageRecord
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.EmployeeID,
		&i.AgentConfigID,
		&i.ResourceType,
		&i.Quantity,
		&i.CostUsd,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Metadata,
		&i.TokenSource,
		&i.CreatedAt,
	)
	return i, err
}

const GetEmployeeUsageStats = `-- name: GetEmployeeUsageStats :one
SELECT
    COUNT(*) as total_records,
    COALESCE(SUM(CASE WHEN resource_type = 'api_calls' THEN quantity ELSE 0 END), 0) as total_api_calls,
    COALESCE(SUM(CASE WHEN resource_type = 'llm_tokens' THEN quantity ELSE 0 END), 0) as total_tokens,
    COALESCE(SUM(cost_usd), 0) as total_cost_usd
FROM usage_records
WHERE employee_id = $1::uuid
  AND period_start >= $2
  AND period_end <= $3
`

type GetEmployeeUsageStatsParams struct {
	EmployeeID  uuid.UUID        `json:"employee_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

type GetEmployeeUsageStatsRow struct {
	TotalRecords  int64       `json:"total_records"`
	TotalApiCalls interface{} `json:"total_api_calls"`
	TotalTokens   interface{} `json:"total_tokens"`
	TotalCostUsd  interface{} `json:"total_cost_usd"`
}

func (q *Queries) GetEmployeeUsageStats(ctx context.Context, arg GetEmployeeUsageStatsParams) (GetEmployeeUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeeUsageStats, arg.EmployeeID, arg.PeriodStart, arg.PeriodEnd)
	var i GetEmployeeUsageStatsRow
	err := row.Scan(
		&i.TotalRecords,
		&i.TotalApiCalls,
		&i.TotalTokens,
		&i.TotalCostUsd,
	)
	return i, err
}

const GetOrgUsageStats = `-- name: GetOrgUsageStats :one
SELECT
    COUNT(*) as total_records,
    COALESCE(SUM(CASE WHEN resource_type = 'api_calls' THEN quantity ELSE 0 END), 0) as total_api_calls,
    COALESCE(SUM(CASE WHEN resource_type = 'llm_tokens' THEN quantity ELSE 0 END), 0) as total_tokens,
    COALESCE(SUM(cost_usd), 0) as total_cost_usd
FROM usage_records
WHERE org_id = $1
  AND period_start >= $2
  AND period_end <= $3
`

type GetOrgUsageStatsParams struct {
	OrgID       uuid.UUID        `json:"org_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

type GetOrgUsageStatsRow struct {
	TotalRecords  int64       `json:"total_records"`
	TotalApiCalls interface{} `json:"total_api_calls"`
	TotalTokens   interface{} `json:"total_tokens"`
	TotalCostUsd  interface{} `json:"total_cost_usd"`
}

func (q *Queries) GetOrgUsageStats(ctx context.Context, arg GetOrgUsageStatsParams) (GetOrgUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, GetOrgUsageStats, arg.OrgID, arg.PeriodStart, arg.PeriodEnd)
	var i GetOrgUsageStatsRow
	err := row.Scan(
		&i.TotalRecords,
		&i.TotalApiCalls,
		&i.TotalTokens,
		&i.TotalCostUsd,
	)
	return i, err
}

const GetUsageRecordsByEmployee = `-- name: GetUsageRecordsByEmployee :many
SELECT id, org_id, employee_id, agent_config_id, resource_type, quantity, cost_usd, period_start, period_end, metadata, token_source, created_at FROM usage_records
WHERE employee_id = $1
  AND period_start >= $2
  AND period_end <= $3
ORDER BY period_start DESC
`

type GetUsageRecordsByEmployeeParams struct {
	EmployeeID  pgtype.UUID      `json:"employee_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

func (q *Queries) GetUsageRecordsByEmployee(ctx context.Context, arg GetUsageRecordsByEmployeeParams) ([]UsageRecord, error) {
	rows, err := q.db.Query(ctx, GetUsageRecordsByEmployee, arg.EmployeeID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageRecord{}
	for rows.Next() {
		var i UsageRecord
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EmployeeID,
			&i.AgentConfigID,
			&i.ResourceType,
			&i.Quantity,
			&i.CostUsd,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Metadata,
			&i.TokenSource,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsageRecordsByOrg = `-- name: GetUsageRecordsByOrg :many
SELECT id, org_id, employee_id, agent_config_id, resource_type, quantity, cost_usd, period_start, period_end, metadata, token_source, created_at FROM usage_records
WHERE org_id = $1
  AND period_start >= $2
  AND period_end <= $3
ORDER BY period_start DESC
`

type GetUsageRecordsByOrgParams struct {
	OrgID       uuid.UUID        `json:"org_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

func (q *Queries) GetUsageRecordsByOrg(ctx context.Context, arg GetUsageRecordsByOrgParams) ([]UsageRecord, error) {
	rows, err := q.db.Query(ctx, GetUsageRecordsByOrg, arg.OrgID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageRecord{}
	for rows.Next() {
		var i UsageRecord
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EmployeeID,
			&i.AgentConfigID,
			&i.ResourceType,
			&i.Quantity,
			&i.CostUsd,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Metadata,
			&i.TokenSource,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
