// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: skills.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const AssignSkillToEmployee = `-- name: AssignSkillToEmployee :one
INSERT INTO employee_skills (
    employee_id,
    skill_id,
    is_enabled,
    config
) VALUES (
    $1, $2, $3, $4
) RETURNING id, employee_id, skill_id, is_enabled, config, created_at, updated_at
`

type AssignSkillToEmployeeParams struct {
	EmployeeID uuid.UUID `json:"employee_id"`
	SkillID    uuid.UUID `json:"skill_id"`
	IsEnabled  *bool     `json:"is_enabled"`
	Config     []byte    `json:"config"`
}

func (q *Queries) AssignSkillToEmployee(ctx context.Context, arg AssignSkillToEmployeeParams) (EmployeeSkill, error) {
	row := q.db.QueryRow(ctx, AssignSkillToEmployee,
		arg.EmployeeID,
		arg.SkillID,
		arg.IsEnabled,
		arg.Config,
	)
	var i EmployeeSkill
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.SkillID,
		&i.IsEnabled,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CountEmployeeSkills = `-- name: CountEmployeeSkills :one
SELECT COUNT(*)
FROM employee_skills
WHERE employee_id = $1
`

func (q *Queries) CountEmployeeSkills(ctx context.Context, employeeID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployeeSkills, employeeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSkill = `-- name: CreateSkill :one
INSERT INTO skill_catalog (
    name,
    description,
    category,
    version,
    files,
    dependencies,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, description, category, version, files, dependencies, is_active, created_at, updated_at
`

type CreateSkillParams struct {
	Name         string          `json:"name"`
	Description  *string         `json:"description"`
	Category     *string         `json:"category"`
	Version      string          `json:"version"`
	Files        json.RawMessage `json:"files"`
	Dependencies []byte          `json:"dependencies"`
	IsActive     *bool           `json:"is_active"`
}

func (q *Queries) CreateSkill(ctx context.Context, arg CreateSkillParams) (SkillCatalog, error) {
	row := q.db.QueryRow(ctx, CreateSkill,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.Version,
		arg.Files,
		arg.Dependencies,
		arg.IsActive,
	)
	var i SkillCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Version,
		&i.Files,
		&i.Dependencies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeactivateSkill = `-- name: DeactivateSkill :exec
UPDATE skill_catalog
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateSkill(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeactivateSkill, id)
	return err
}

const DeleteSkill = `-- name: DeleteSkill :exec
DELETE FROM skill_catalog
WHERE id = $1
`

func (q *Queries) DeleteSkill(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteSkill, id)
	return err
}

const GetEmployeeSkill = `-- name: GetEmployeeSkill :one
SELECT
    sc.id, sc.name, sc.description, sc.category, sc.version, sc.files, sc.dependencies, sc.is_active, sc.created_at, sc.updated_at,
    es.is_enabled,
    es.config,
    es.created_at as installed_at
FROM skill_catalog sc
JOIN employee_skills es ON es.skill_id = sc.id
WHERE es.employee_id = $1 AND es.skill_id = $2
`

type GetEmployeeSkillParams struct {
	EmployeeID uuid.UUID `json:"employee_id"`
	SkillID    uuid.UUID `json:"skill_id"`
}

type GetEmployeeSkillRow struct {
	ID           uuid.UUID        `json:"id"`
	Name         string           `json:"name"`
	Description  *string          `json:"description"`
	Category     *string          `json:"category"`
	Version      string           `json:"version"`
	Files        json.RawMessage  `json:"files"`
	Dependencies []byte           `json:"dependencies"`
	IsActive     *bool            `json:"is_active"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	IsEnabled    *bool            `json:"is_enabled"`
	Config       []byte           `json:"config"`
	InstalledAt  pgtype.Timestamp `json:"installed_at"`
}

func (q *Queries) GetEmployeeSkill(ctx context.Context, arg GetEmployeeSkillParams) (GetEmployeeSkillRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeeSkill, arg.EmployeeID, arg.SkillID)
	var i GetEmployeeSkillRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Version,
		&i.Files,
		&i.Dependencies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
		&i.Config,
		&i.InstalledAt,
	)
	return i, err
}

const GetSkill = `-- name: GetSkill :one
SELECT id, name, description, category, version, files, dependencies, is_active, created_at, updated_at FROM skill_catalog
WHERE id = $1
`

func (q *Queries) GetSkill(ctx context.Context, id uuid.UUID) (SkillCatalog, error) {
	row := q.db.QueryRow(ctx, GetSkill, id)
	var i SkillCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Version,
		&i.Files,
		&i.Dependencies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSkillByName = `-- name: GetSkillByName :one
SELECT id, name, description, category, version, files, dependencies, is_active, created_at, updated_at FROM skill_catalog
WHERE name = $1
`

func (q *Queries) GetSkillByName(ctx context.Context, name string) (SkillCatalog, error) {
	row := q.db.QueryRow(ctx, GetSkillByName, name)
	var i SkillCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Version,
		&i.Files,
		&i.Dependencies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSkillUsageCount = `-- name: GetSkillUsageCount :one
SELECT COUNT(*)
FROM employee_skills
WHERE skill_id = $1 AND is_enabled = true
`

func (q *Queries) GetSkillUsageCount(ctx context.Context, skillID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, GetSkillUsageCount, skillID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ListAllSkills = `-- name: ListAllSkills :many
SELECT id, name, description, category, version, files, dependencies, is_active, created_at, updated_at FROM skill_catalog
ORDER BY category, name
`

func (q *Queries) ListAllSkills(ctx context.Context) ([]SkillCatalog, error) {
	rows, err := q.db.Query(ctx, ListAllSkills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SkillCatalog{}
	for rows.Next() {
		var i SkillCatalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Version,
			&i.Files,
			&i.Dependencies,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEmployeeSkills = `-- name: ListEmployeeSkills :many

SELECT
    sc.id,
    sc.name,
    sc.description,
    sc.category,
    sc.version,
    sc.files,
    sc.dependencies,
    sc.is_active,
    es.is_enabled,
    es.config,
    es.created_at as installed_at
FROM skill_catalog sc
JOIN employee_skills es ON es.skill_id = sc.id
WHERE es.employee_id = $1
ORDER BY sc.category, sc.name
`

type ListEmployeeSkillsRow struct {
	ID           uuid.UUID        `json:"id"`
	Name         string           `json:"name"`
	Description  *string          `json:"description"`
	Category     *string          `json:"category"`
	Version      string           `json:"version"`
	Files        json.RawMessage  `json:"files"`
	Dependencies []byte           `json:"dependencies"`
	IsActive     *bool            `json:"is_active"`
	IsEnabled    *bool            `json:"is_enabled"`
	Config       []byte           `json:"config"`
	InstalledAt  pgtype.Timestamp `json:"installed_at"`
}

// ============================================================================
// Employee Skills Queries
// ============================================================================
func (q *Queries) ListEmployeeSkills(ctx context.Context, employeeID uuid.UUID) ([]ListEmployeeSkillsRow, error) {
	rows, err := q.db.Query(ctx, ListEmployeeSkills, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeeSkillsRow{}
	for rows.Next() {
		var i ListEmployeeSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Version,
			&i.Files,
			&i.Dependencies,
			&i.IsActive,
			&i.IsEnabled,
			&i.Config,
			&i.InstalledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSkills = `-- name: ListSkills :many

SELECT id, name, description, category, version, files, dependencies, is_active, created_at, updated_at FROM skill_catalog
WHERE is_active = true
ORDER BY category, name
`

// ============================================================================
// Skills Catalog Queries
// ============================================================================
func (q *Queries) ListSkills(ctx context.Context) ([]SkillCatalog, error) {
	rows, err := q.db.Query(ctx, ListSkills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SkillCatalog{}
	for rows.Next() {
		var i SkillCatalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Version,
			&i.Files,
			&i.Dependencies,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveSkillFromEmployee = `-- name: RemoveSkillFromEmployee :exec
DELETE FROM employee_skills
WHERE employee_id = $1 AND skill_id = $2
`

type RemoveSkillFromEmployeeParams struct {
	EmployeeID uuid.UUID `json:"employee_id"`
	SkillID    uuid.UUID `json:"skill_id"`
}

func (q *Queries) RemoveSkillFromEmployee(ctx context.Context, arg RemoveSkillFromEmployeeParams) error {
	_, err := q.db.Exec(ctx, RemoveSkillFromEmployee, arg.EmployeeID, arg.SkillID)
	return err
}

const UpdateEmployeeSkill = `-- name: UpdateEmployeeSkill :one
UPDATE employee_skills
SET
    is_enabled = COALESCE($1, is_enabled),
    config = COALESCE($2, config),
    updated_at = NOW()
WHERE employee_id = $3 AND skill_id = $4
RETURNING id, employee_id, skill_id, is_enabled, config, created_at, updated_at
`

type UpdateEmployeeSkillParams struct {
	IsEnabled  *bool     `json:"is_enabled"`
	Config     []byte    `json:"config"`
	EmployeeID uuid.UUID `json:"employee_id"`
	SkillID    uuid.UUID `json:"skill_id"`
}

func (q *Queries) UpdateEmployeeSkill(ctx context.Context, arg UpdateEmployeeSkillParams) (EmployeeSkill, error) {
	row := q.db.QueryRow(ctx, UpdateEmployeeSkill,
		arg.IsEnabled,
		arg.Config,
		arg.EmployeeID,
		arg.SkillID,
	)
	var i EmployeeSkill
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.SkillID,
		&i.IsEnabled,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateSkill = `-- name: UpdateSkill :one
UPDATE skill_catalog
SET
    description = COALESCE($1, description),
    category = COALESCE($2, category),
    version = COALESCE($3, version),
    files = COALESCE($4, files),
    dependencies = COALESCE($5, dependencies),
    is_active = COALESCE($6, is_active),
    updated_at = NOW()
WHERE id = $7
RETURNING id, name, description, category, version, files, dependencies, is_active, created_at, updated_at
`

type UpdateSkillParams struct {
	Description  *string   `json:"description"`
	Category     *string   `json:"category"`
	Version      *string   `json:"version"`
	Files        []byte    `json:"files"`
	Dependencies []byte    `json:"dependencies"`
	IsActive     *bool     `json:"is_active"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSkill(ctx context.Context, arg UpdateSkillParams) (SkillCatalog, error) {
	row := q.db.QueryRow(ctx, UpdateSkill,
		arg.Description,
		arg.Category,
		arg.Version,
		arg.Files,
		arg.Dependencies,
		arg.IsActive,
		arg.ID,
	)
	var i SkillCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Version,
		&i.Files,
		&i.Dependencies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
