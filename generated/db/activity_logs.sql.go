// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity_logs.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountActivityLogs = `-- name: CountActivityLogs :one
SELECT COUNT(*) FROM activity_logs
WHERE org_id = $1
`

// Count total activity logs for an organization
func (q *Queries) CountActivityLogs(ctx context.Context, orgID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountActivityLogs, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateActivityLog = `-- name: CreateActivityLog :one
INSERT INTO activity_logs (
    org_id,
    employee_id,
    session_id,
    agent_id,
    event_type,
    event_category,
    content,
    payload
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, org_id, employee_id, session_id, agent_id, event_type, event_category, content, payload, created_at
`

type CreateActivityLogParams struct {
	OrgID         uuid.UUID       `json:"org_id"`
	EmployeeID    pgtype.UUID     `json:"employee_id"`
	SessionID     pgtype.UUID     `json:"session_id"`
	AgentID       pgtype.UUID     `json:"agent_id"`
	EventType     string          `json:"event_type"`
	EventCategory string          `json:"event_category"`
	Content       *string         `json:"content"`
	Payload       json.RawMessage `json:"payload"`
}

// Create a new activity log entry
func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, CreateActivityLog,
		arg.OrgID,
		arg.EmployeeID,
		arg.SessionID,
		arg.AgentID,
		arg.EventType,
		arg.EventCategory,
		arg.Content,
		arg.Payload,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.EmployeeID,
		&i.SessionID,
		&i.AgentID,
		&i.EventType,
		&i.EventCategory,
		&i.Content,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteOldLogs = `-- name: DeleteOldLogs :exec
DELETE FROM activity_logs
WHERE created_at < $1
`

// Delete activity logs older than specified timestamp
func (q *Queries) DeleteOldLogs(ctx context.Context, createdAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, DeleteOldLogs, createdAt)
	return err
}

const GetLogsByEmployee = `-- name: GetLogsByEmployee :many
SELECT
    id,
    org_id,
    employee_id,
    session_id,
    agent_id,
    event_type,
    event_category,
    content,
    payload,
    created_at
FROM activity_logs
WHERE org_id = $1
    AND employee_id = $2
    AND ($3::VARCHAR IS NULL OR event_category = $3)
    AND ($4::TIMESTAMP IS NULL OR created_at >= $4)
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type GetLogsByEmployeeParams struct {
	OrgID         uuid.UUID        `json:"org_id"`
	EmployeeID    pgtype.UUID      `json:"employee_id"`
	EventCategory *string          `json:"event_category"`
	Since         pgtype.Timestamp `json:"since"`
	QueryOffset   int32            `json:"query_offset"`
	QueryLimit    int32            `json:"query_limit"`
}

// Get logs for a specific employee with filters
func (q *Queries) GetLogsByEmployee(ctx context.Context, arg GetLogsByEmployeeParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, GetLogsByEmployee,
		arg.OrgID,
		arg.EmployeeID,
		arg.EventCategory,
		arg.Since,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EmployeeID,
			&i.SessionID,
			&i.AgentID,
			&i.EventType,
			&i.EventCategory,
			&i.Content,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLogsBySession = `-- name: GetLogsBySession :many
SELECT
    id,
    org_id,
    employee_id,
    session_id,
    agent_id,
    event_type,
    event_category,
    content,
    payload,
    created_at
FROM activity_logs
WHERE session_id = $1
ORDER BY created_at ASC
`

// Get all logs for a specific CLI session
func (q *Queries) GetLogsBySession(ctx context.Context, sessionID pgtype.UUID) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, GetLogsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EmployeeID,
			&i.SessionID,
			&i.AgentID,
			&i.EventType,
			&i.EventCategory,
			&i.Content,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActivityLogs = `-- name: ListActivityLogs :many
SELECT
    id,
    org_id,
    employee_id,
    session_id,
    agent_id,
    event_type,
    event_category,
    content,
    payload,
    created_at
FROM activity_logs
WHERE org_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivityLogsParams struct {
	OrgID  uuid.UUID `json:"org_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

// List recent activity logs for an organization with pagination
func (q *Queries) ListActivityLogs(ctx context.Context, arg ListActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, ListActivityLogs, arg.OrgID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.EmployeeID,
			&i.SessionID,
			&i.AgentID,
			&i.EventType,
			&i.EventCategory,
			&i.Content,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
