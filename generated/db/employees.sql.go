// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: employees.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountEmployees = `-- name: CountEmployees :one
SELECT COUNT(*) FROM employees
WHERE org_id = $1
  AND ($2::text IS NULL OR status = $2::text)
  AND ($3::uuid IS NULL OR team_id = $3::uuid)
  AND ($4::text IS NULL OR full_name ILIKE '%' || $4::text || '%' OR email ILIKE '%' || $4::text || '%')
`

type CountEmployeesParams struct {
	OrgID  uuid.UUID   `json:"org_id"`
	Status *string     `json:"status"`
	TeamID pgtype.UUID `json:"team_id"`
	Search *string     `json:"search"`
}

func (q *Queries) CountEmployees(ctx context.Context, arg CountEmployeesParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployees,
		arg.OrgID,
		arg.Status,
		arg.TeamID,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountEmployeesByRole = `-- name: CountEmployeesByRole :one
SELECT COUNT(*) as count
FROM employees
WHERE role_id = $1
`

func (q *Queries) CountEmployeesByRole(ctx context.Context, roleID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployeesByRole, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountEmployeesByTeam = `-- name: CountEmployeesByTeam :one
SELECT COUNT(*) as count
FROM employees
WHERE team_id = $1
`

func (q *Queries) CountEmployeesByTeam(ctx context.Context, teamID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployeesByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
    org_id,
    team_id,
    role_id,
    email,
    full_name,
    password_hash,
    status,
    preferences
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, org_id, team_id, role_id, email, full_name, password_hash, status, preferences, personal_claude_token, last_login_at, created_at, updated_at, deleted_at
`

type CreateEmployeeParams struct {
	OrgID        uuid.UUID       `json:"org_id"`
	TeamID       pgtype.UUID     `json:"team_id"`
	RoleID       uuid.UUID       `json:"role_id"`
	Email        string          `json:"email"`
	FullName     string          `json:"full_name"`
	PasswordHash string          `json:"password_hash"`
	Status       string          `json:"status"`
	Preferences  json.RawMessage `json:"preferences"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, CreateEmployee,
		arg.OrgID,
		arg.TeamID,
		arg.RoleID,
		arg.Email,
		arg.FullName,
		arg.PasswordHash,
		arg.Status,
		arg.Preferences,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Status,
		&i.Preferences,
		&i.PersonalClaudeToken,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const DeleteEmployee = `-- name: DeleteEmployee :exec
DELETE FROM employees
WHERE id = $1
`

func (q *Queries) DeleteEmployee(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteEmployee, id)
	return err
}

const GetEmployee = `-- name: GetEmployee :one

SELECT id, org_id, team_id, role_id, email, full_name, password_hash, status, preferences, personal_claude_token, last_login_at, created_at, updated_at, deleted_at FROM employees
WHERE id = $1
`

// Employee queries for sqlc code generation
func (q *Queries) GetEmployee(ctx context.Context, id uuid.UUID) (Employee, error) {
	row := q.db.QueryRow(ctx, GetEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Status,
		&i.Preferences,
		&i.PersonalClaudeToken,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetEmployeeByEmail = `-- name: GetEmployeeByEmail :one
SELECT id, org_id, team_id, role_id, email, full_name, password_hash, status, preferences, personal_claude_token, last_login_at, created_at, updated_at, deleted_at FROM employees
WHERE email = $1
`

func (q *Queries) GetEmployeeByEmail(ctx context.Context, email string) (Employee, error) {
	row := q.db.QueryRow(ctx, GetEmployeeByEmail, email)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Status,
		&i.Preferences,
		&i.PersonalClaudeToken,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const GetEmployeeWithRole = `-- name: GetEmployeeWithRole :one
SELECT
    e.id, e.org_id, e.team_id, e.role_id, e.email, e.full_name, e.password_hash, e.status, e.preferences, e.personal_claude_token, e.last_login_at, e.created_at, e.updated_at, e.deleted_at,
    r.name as role_name,
    r.permissions as role_permissions
FROM employees e
JOIN roles r ON e.role_id = r.id
WHERE e.id = $1
`

type GetEmployeeWithRoleRow struct {
	ID                  uuid.UUID        `json:"id"`
	OrgID               uuid.UUID        `json:"org_id"`
	TeamID              pgtype.UUID      `json:"team_id"`
	RoleID              uuid.UUID        `json:"role_id"`
	Email               string           `json:"email"`
	FullName            string           `json:"full_name"`
	PasswordHash        string           `json:"password_hash"`
	Status              string           `json:"status"`
	Preferences         json.RawMessage  `json:"preferences"`
	PersonalClaudeToken *string          `json:"personal_claude_token"`
	LastLoginAt         pgtype.Timestamp `json:"last_login_at"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	DeletedAt           pgtype.Timestamp `json:"deleted_at"`
	RoleName            string           `json:"role_name"`
	RolePermissions     json.RawMessage  `json:"role_permissions"`
}

func (q *Queries) GetEmployeeWithRole(ctx context.Context, id uuid.UUID) (GetEmployeeWithRoleRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeeWithRole, id)
	var i GetEmployeeWithRoleRow
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Status,
		&i.Preferences,
		&i.PersonalClaudeToken,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RoleName,
		&i.RolePermissions,
	)
	return i, err
}

const GetEmployeesByTeam = `-- name: GetEmployeesByTeam :many
SELECT id, org_id, team_id, role_id, email, full_name, password_hash, status, preferences, personal_claude_token, last_login_at, created_at, updated_at, deleted_at FROM employees
WHERE team_id = $1
ORDER BY full_name
`

func (q *Queries) GetEmployeesByTeam(ctx context.Context, teamID pgtype.UUID) ([]Employee, error) {
	rows, err := q.db.Query(ctx, GetEmployeesByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.TeamID,
			&i.RoleID,
			&i.Email,
			&i.FullName,
			&i.PasswordHash,
			&i.Status,
			&i.Preferences,
			&i.PersonalClaudeToken,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEmployees = `-- name: ListEmployees :many
SELECT
  e.id, e.org_id, e.team_id, e.role_id, e.email, e.full_name, e.password_hash, e.status, e.preferences, e.personal_claude_token, e.last_login_at, e.created_at, e.updated_at, e.deleted_at,
  t.name as team_name
FROM employees e
LEFT JOIN teams t ON e.team_id = t.id
WHERE e.org_id = $1
  AND ($2::text IS NULL OR e.status = $2::text)
  AND ($3::uuid IS NULL OR e.team_id = $3::uuid)
  AND ($4::text IS NULL OR e.full_name ILIKE '%' || $4::text || '%' OR e.email ILIKE '%' || $4::text || '%')
ORDER BY e.created_at DESC
LIMIT $6 OFFSET $5
`

type ListEmployeesParams struct {
	OrgID       uuid.UUID   `json:"org_id"`
	Status      *string     `json:"status"`
	TeamID      pgtype.UUID `json:"team_id"`
	Search      *string     `json:"search"`
	QueryOffset int32       `json:"query_offset"`
	QueryLimit  int32       `json:"query_limit"`
}

type ListEmployeesRow struct {
	ID                  uuid.UUID        `json:"id"`
	OrgID               uuid.UUID        `json:"org_id"`
	TeamID              pgtype.UUID      `json:"team_id"`
	RoleID              uuid.UUID        `json:"role_id"`
	Email               string           `json:"email"`
	FullName            string           `json:"full_name"`
	PasswordHash        string           `json:"password_hash"`
	Status              string           `json:"status"`
	Preferences         json.RawMessage  `json:"preferences"`
	PersonalClaudeToken *string          `json:"personal_claude_token"`
	LastLoginAt         pgtype.Timestamp `json:"last_login_at"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	DeletedAt           pgtype.Timestamp `json:"deleted_at"`
	TeamName            *string          `json:"team_name"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]ListEmployeesRow, error) {
	rows, err := q.db.Query(ctx, ListEmployees,
		arg.OrgID,
		arg.Status,
		arg.TeamID,
		arg.Search,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesRow{}
	for rows.Next() {
		var i ListEmployeesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.TeamID,
			&i.RoleID,
			&i.Email,
			&i.FullName,
			&i.PasswordHash,
			&i.Status,
			&i.Preferences,
			&i.PersonalClaudeToken,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEmployee = `-- name: UpdateEmployee :one
UPDATE employees
SET
    full_name = COALESCE($2, full_name),
    team_id = COALESCE($3, team_id),
    role_id = COALESCE($4, role_id),
    status = COALESCE($5, status),
    preferences = COALESCE($6, preferences),
    updated_at = NOW()
WHERE id = $1
RETURNING id, org_id, team_id, role_id, email, full_name, password_hash, status, preferences, personal_claude_token, last_login_at, created_at, updated_at, deleted_at
`

type UpdateEmployeeParams struct {
	ID          uuid.UUID       `json:"id"`
	FullName    string          `json:"full_name"`
	TeamID      pgtype.UUID     `json:"team_id"`
	RoleID      uuid.UUID       `json:"role_id"`
	Status      string          `json:"status"`
	Preferences json.RawMessage `json:"preferences"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, UpdateEmployee,
		arg.ID,
		arg.FullName,
		arg.TeamID,
		arg.RoleID,
		arg.Status,
		arg.Preferences,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.TeamID,
		&i.RoleID,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Status,
		&i.Preferences,
		&i.PersonalClaudeToken,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const UpdateEmployeeLastLogin = `-- name: UpdateEmployeeLastLogin :exec
UPDATE employees
SET last_login_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateEmployeeLastLogin(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, UpdateEmployeeLastLogin, id)
	return err
}
