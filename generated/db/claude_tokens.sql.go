// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: claude_tokens.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountEmployeesWithPersonalTokens = `-- name: CountEmployeesWithPersonalTokens :one

SELECT COUNT(*) as count
FROM employees
WHERE org_id = $1
AND personal_claude_token IS NOT NULL
AND deleted_at IS NULL
`

// ============================================================================
// TOKEN STATISTICS
// ============================================================================
func (q *Queries) CountEmployeesWithPersonalTokens(ctx context.Context, orgID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployeesWithPersonalTokens, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteEmployeePersonalToken = `-- name: DeleteEmployeePersonalToken :exec
UPDATE employees
SET personal_claude_token = NULL,
    updated_at = NOW()
WHERE id = $1
AND deleted_at IS NULL
`

func (q *Queries) DeleteEmployeePersonalToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteEmployeePersonalToken, id)
	return err
}

const DeleteOrganizationClaudeToken = `-- name: DeleteOrganizationClaudeToken :exec
UPDATE organizations
SET claude_api_token = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteOrganizationClaudeToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteOrganizationClaudeToken, id)
	return err
}

const GetEffectiveClaudeToken = `-- name: GetEffectiveClaudeToken :one

SELECT
    COALESCE(e.personal_claude_token, o.claude_api_token) as token,
    CASE
        WHEN e.personal_claude_token IS NOT NULL THEN 'personal'
        ELSE 'company'
    END as source,
    e.org_id,
    e.id as employee_id,
    o.name as org_name
FROM employees e
JOIN organizations o ON e.org_id = o.id
WHERE e.id = $1
AND e.deleted_at IS NULL
`

type GetEffectiveClaudeTokenRow struct {
	Token      *string   `json:"token"`
	Source     string    `json:"source"`
	OrgID      uuid.UUID `json:"org_id"`
	EmployeeID uuid.UUID `json:"employee_id"`
	OrgName    string    `json:"org_name"`
}

// ============================================================================
// TOKEN RESOLUTION
// ============================================================================
func (q *Queries) GetEffectiveClaudeToken(ctx context.Context, id uuid.UUID) (GetEffectiveClaudeTokenRow, error) {
	row := q.db.QueryRow(ctx, GetEffectiveClaudeToken, id)
	var i GetEffectiveClaudeTokenRow
	err := row.Scan(
		&i.Token,
		&i.Source,
		&i.OrgID,
		&i.EmployeeID,
		&i.OrgName,
	)
	return i, err
}

const GetEmployeePersonalToken = `-- name: GetEmployeePersonalToken :one
SELECT id, full_name, email, personal_claude_token, updated_at
FROM employees
WHERE id = $1
AND deleted_at IS NULL
`

type GetEmployeePersonalTokenRow struct {
	ID                  uuid.UUID        `json:"id"`
	FullName            string           `json:"full_name"`
	Email               string           `json:"email"`
	PersonalClaudeToken *string          `json:"personal_claude_token"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetEmployeePersonalToken(ctx context.Context, id uuid.UUID) (GetEmployeePersonalTokenRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeePersonalToken, id)
	var i GetEmployeePersonalTokenRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PersonalClaudeToken,
		&i.UpdatedAt,
	)
	return i, err
}

const GetEmployeeTokenStatus = `-- name: GetEmployeeTokenStatus :one
SELECT
    e.id as employee_id,
    e.full_name,
    e.personal_claude_token IS NOT NULL as has_personal_token,
    o.claude_api_token IS NOT NULL as has_company_token,
    CASE
        WHEN e.personal_claude_token IS NOT NULL THEN 'personal'
        WHEN o.claude_api_token IS NOT NULL THEN 'company'
        ELSE 'none'
    END as active_token_source
FROM employees e
JOIN organizations o ON e.org_id = o.id
WHERE e.id = $1
AND e.deleted_at IS NULL
`

type GetEmployeeTokenStatusRow struct {
	EmployeeID        uuid.UUID   `json:"employee_id"`
	FullName          string      `json:"full_name"`
	HasPersonalToken  interface{} `json:"has_personal_token"`
	HasCompanyToken   interface{} `json:"has_company_token"`
	ActiveTokenSource string      `json:"active_token_source"`
}

func (q *Queries) GetEmployeeTokenStatus(ctx context.Context, id uuid.UUID) (GetEmployeeTokenStatusRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeeTokenStatus, id)
	var i GetEmployeeTokenStatusRow
	err := row.Scan(
		&i.EmployeeID,
		&i.FullName,
		&i.HasPersonalToken,
		&i.HasCompanyToken,
		&i.ActiveTokenSource,
	)
	return i, err
}

const GetOrganizationClaudeToken = `-- name: GetOrganizationClaudeToken :one
SELECT id, name, claude_api_token, updated_at
FROM organizations
WHERE id = $1
`

type GetOrganizationClaudeTokenRow struct {
	ID             uuid.UUID        `json:"id"`
	Name           string           `json:"name"`
	ClaudeApiToken *string          `json:"claude_api_token"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetOrganizationClaudeToken(ctx context.Context, id uuid.UUID) (GetOrganizationClaudeTokenRow, error) {
	row := q.db.QueryRow(ctx, GetOrganizationClaudeToken, id)
	var i GetOrganizationClaudeTokenRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClaudeApiToken,
		&i.UpdatedAt,
	)
	return i, err
}

const GetTokenUsageBySource = `-- name: GetTokenUsageBySource :many
SELECT
    token_source,
    COUNT(*) as usage_count,
    SUM(cost_usd) as total_cost
FROM usage_records
WHERE org_id = $1
AND period_start >= $2
AND period_end <= $3
GROUP BY token_source
`

type GetTokenUsageBySourceParams struct {
	OrgID       uuid.UUID        `json:"org_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

type GetTokenUsageBySourceRow struct {
	TokenSource *string `json:"token_source"`
	UsageCount  int64   `json:"usage_count"`
	TotalCost   int64   `json:"total_cost"`
}

func (q *Queries) GetTokenUsageBySource(ctx context.Context, arg GetTokenUsageBySourceParams) ([]GetTokenUsageBySourceRow, error) {
	rows, err := q.db.Query(ctx, GetTokenUsageBySource, arg.OrgID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokenUsageBySourceRow{}
	for rows.Next() {
		var i GetTokenUsageBySourceRow
		if err := rows.Scan(&i.TokenSource, &i.UsageCount, &i.TotalCost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetEmployeePersonalToken = `-- name: SetEmployeePersonalToken :exec

UPDATE employees
SET personal_claude_token = $2,
    updated_at = NOW()
WHERE id = $1
AND deleted_at IS NULL
`

type SetEmployeePersonalTokenParams struct {
	ID                  uuid.UUID `json:"id"`
	PersonalClaudeToken *string   `json:"personal_claude_token"`
}

// ============================================================================
// EMPLOYEE TOKEN MANAGEMENT
// ============================================================================
func (q *Queries) SetEmployeePersonalToken(ctx context.Context, arg SetEmployeePersonalTokenParams) error {
	_, err := q.db.Exec(ctx, SetEmployeePersonalToken, arg.ID, arg.PersonalClaudeToken)
	return err
}

const SetOrganizationClaudeToken = `-- name: SetOrganizationClaudeToken :exec


UPDATE organizations
SET claude_api_token = $2,
    updated_at = NOW()
WHERE id = $1
`

type SetOrganizationClaudeTokenParams struct {
	ID             uuid.UUID `json:"id"`
	ClaudeApiToken *string   `json:"claude_api_token"`
}

// Claude Token Management Queries
// These queries manage the hybrid authentication model for Claude Code
// ============================================================================
// ORGANIZATION TOKEN MANAGEMENT
// ============================================================================
func (q *Queries) SetOrganizationClaudeToken(ctx context.Context, arg SetOrganizationClaudeTokenParams) error {
	_, err := q.db.Exec(ctx, SetOrganizationClaudeToken, arg.ID, arg.ClaudeApiToken)
	return err
}
