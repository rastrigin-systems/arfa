// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const AcceptInvitation = `-- name: AcceptInvitation :one
UPDATE invitations
SET
    status = 'accepted',
    accepted_at = NOW(),
    accepted_by = $2,
    updated_at = NOW()
WHERE token = $1 AND status = 'pending' AND expires_at > NOW()
RETURNING id, org_id, inviter_id, email, role_id, team_id, token, status, expires_at, accepted_by, accepted_at, created_at, updated_at
`

type AcceptInvitationParams struct {
	Token      string      `json:"token"`
	AcceptedBy pgtype.UUID `json:"accepted_by"`
}

// Accept an invitation (updates status and records acceptance)
// Used by POST /invitations/{token}/accept
// Note: Must be called within a transaction that also creates the employee
func (q *Queries) AcceptInvitation(ctx context.Context, arg AcceptInvitationParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, AcceptInvitation, arg.Token, arg.AcceptedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.InviterID,
		&i.Email,
		&i.RoleID,
		&i.TeamID,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CancelInvitation = `-- name: CancelInvitation :exec
UPDATE invitations
SET
    status = 'cancelled',
    updated_at = NOW()
WHERE id = $1 AND org_id = $2 AND status = 'pending'
`

type CancelInvitationParams struct {
	ID    uuid.UUID `json:"id"`
	OrgID uuid.UUID `json:"org_id"`
}

// Cancel a pending invitation
// Used by DELETE /invitations/{id} (admin only)
func (q *Queries) CancelInvitation(ctx context.Context, arg CancelInvitationParams) error {
	_, err := q.db.Exec(ctx, CancelInvitation, arg.ID, arg.OrgID)
	return err
}

const CountInvitations = `-- name: CountInvitations :one
SELECT COUNT(*) FROM invitations
WHERE org_id = $1
`

// Count total invitations for an organization (for pagination)
// Used by GET /invitations (admin only)
func (q *Queries) CountInvitations(ctx context.Context, orgID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountInvitations, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountInvitationsByOrgToday = `-- name: CountInvitationsByOrgToday :one
SELECT COUNT(*) FROM invitations
WHERE org_id = $1
  AND created_at >= CURRENT_DATE
  AND created_at < CURRENT_DATE + INTERVAL '1 day'
`

// Count invitations created today for rate limiting (20/day)
// Used by POST /invitations for rate limiting validation
func (q *Queries) CountInvitationsByOrgToday(ctx context.Context, orgID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountInvitationsByOrgToday, orgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (
    org_id,
    inviter_id,
    email,
    role_id,
    team_id,
    token,
    status,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, 'pending', NOW() + INTERVAL '7 days'
) RETURNING id, org_id, inviter_id, email, role_id, team_id, token, status, expires_at, accepted_by, accepted_at, created_at, updated_at
`

type CreateInvitationParams struct {
	OrgID     uuid.UUID   `json:"org_id"`
	InviterID uuid.UUID   `json:"inviter_id"`
	Email     string      `json:"email"`
	RoleID    uuid.UUID   `json:"role_id"`
	TeamID    pgtype.UUID `json:"team_id"`
	Token     string      `json:"token"`
}

// Create a new invitation with a secure token
// Used by POST /invitations (admin only)
func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, CreateInvitation,
		arg.OrgID,
		arg.InviterID,
		arg.Email,
		arg.RoleID,
		arg.TeamID,
		arg.Token,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.InviterID,
		&i.Email,
		&i.RoleID,
		&i.TeamID,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ExpireOldInvitations = `-- name: ExpireOldInvitations :exec
UPDATE invitations
SET status = 'expired', updated_at = NOW()
WHERE status = 'pending' AND expires_at <= NOW()
`

// Mark expired invitations (background job)
// Used by scheduled cleanup task
func (q *Queries) ExpireOldInvitations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ExpireOldInvitations)
	return err
}

const GetInvitationByID = `-- name: GetInvitationByID :one
SELECT id, org_id, inviter_id, email, role_id, team_id, token, status, expires_at, accepted_by, accepted_at, created_at, updated_at FROM invitations
WHERE id = $1 AND org_id = $2
`

type GetInvitationByIDParams struct {
	ID    uuid.UUID `json:"id"`
	OrgID uuid.UUID `json:"org_id"`
}

// Get invitation by ID (for cancellation)
// Used by DELETE /invitations/{id} (admin only)
func (q *Queries) GetInvitationByID(ctx context.Context, arg GetInvitationByIDParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, GetInvitationByID, arg.ID, arg.OrgID)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.InviterID,
		&i.Email,
		&i.RoleID,
		&i.TeamID,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetInvitationByToken = `-- name: GetInvitationByToken :one
SELECT
    i.id, i.org_id, i.inviter_id, i.email, i.role_id, i.team_id, i.token, i.status, i.expires_at, i.accepted_by, i.accepted_at, i.created_at, i.updated_at,
    o.name as org_name,
    r.name as role_name,
    t.name as team_name
FROM invitations i
JOIN organizations o ON i.org_id = o.id
JOIN roles r ON i.role_id = r.id
LEFT JOIN teams t ON i.team_id = t.id
WHERE i.token = $1
`

type GetInvitationByTokenRow struct {
	ID         uuid.UUID        `json:"id"`
	OrgID      uuid.UUID        `json:"org_id"`
	InviterID  uuid.UUID        `json:"inviter_id"`
	Email      string           `json:"email"`
	RoleID     uuid.UUID        `json:"role_id"`
	TeamID     pgtype.UUID      `json:"team_id"`
	Token      string           `json:"token"`
	Status     string           `json:"status"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	AcceptedBy pgtype.UUID      `json:"accepted_by"`
	AcceptedAt pgtype.Timestamp `json:"accepted_at"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	OrgName    string           `json:"org_name"`
	RoleName   string           `json:"role_name"`
	TeamName   *string          `json:"team_name"`
}

// Get invitation details by token (for validation)
// Used by GET /invitations/{token} (public)
func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, GetInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.InviterID,
		&i.Email,
		&i.RoleID,
		&i.TeamID,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgName,
		&i.RoleName,
		&i.TeamName,
	)
	return i, err
}

const GetInvitationEmailInfo = `-- name: GetInvitationEmailInfo :one
SELECT
    e.full_name as inviter_name,
    o.name as org_name
FROM invitations i
JOIN employees e ON i.inviter_id = e.id
JOIN organizations o ON i.org_id = o.id
WHERE i.id = $1
`

type GetInvitationEmailInfoRow struct {
	InviterName string `json:"inviter_name"`
	OrgName     string `json:"org_name"`
}

// Get information needed to send invitation email
// Used by POST /invitations after creating invitation
func (q *Queries) GetInvitationEmailInfo(ctx context.Context, id uuid.UUID) (GetInvitationEmailInfoRow, error) {
	row := q.db.QueryRow(ctx, GetInvitationEmailInfo, id)
	var i GetInvitationEmailInfoRow
	err := row.Scan(&i.InviterName, &i.OrgName)
	return i, err
}

const ListInvitations = `-- name: ListInvitations :many
SELECT id, org_id, inviter_id, email, role_id, team_id, token, status, expires_at, accepted_by, accepted_at, created_at, updated_at FROM invitations
WHERE org_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvitationsParams struct {
	OrgID  uuid.UUID `json:"org_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

// List all invitations for an organization with pagination
// Used by GET /invitations (admin only)
func (q *Queries) ListInvitations(ctx context.Context, arg ListInvitationsParams) ([]Invitation, error) {
	rows, err := q.db.Query(ctx, ListInvitations, arg.OrgID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invitation{}
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.InviterID,
			&i.Email,
			&i.RoleID,
			&i.TeamID,
			&i.Token,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedBy,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
