// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mcp_servers.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const ApproveMCPServer = `-- name: ApproveMCPServer :exec
UPDATE mcp_catalog
SET is_approved = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ApproveMCPServer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, ApproveMCPServer, id)
	return err
}

const CountEmployeeMCPConfigs = `-- name: CountEmployeeMCPConfigs :one
SELECT COUNT(*)
FROM employee_mcp_configs
WHERE employee_id = $1
`

func (q *Queries) CountEmployeeMCPConfigs(ctx context.Context, employeeID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmployeeMCPConfigs, employeeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateEmployeeMCPConfig = `-- name: CreateEmployeeMCPConfig :one
INSERT INTO employee_mcp_configs (
    employee_id,
    mcp_catalog_id,
    connection_config,
    is_enabled
) VALUES (
    $1, $2, $3, $4
) RETURNING id, employee_id, mcp_catalog_id, status, connection_config, credentials_encrypted, sync_token, last_sync_at, created_at, updated_at, is_enabled
`

type CreateEmployeeMCPConfigParams struct {
	EmployeeID       uuid.UUID       `json:"employee_id"`
	McpCatalogID     uuid.UUID       `json:"mcp_catalog_id"`
	ConnectionConfig json.RawMessage `json:"connection_config"`
	IsEnabled        *bool           `json:"is_enabled"`
}

func (q *Queries) CreateEmployeeMCPConfig(ctx context.Context, arg CreateEmployeeMCPConfigParams) (EmployeeMcpConfig, error) {
	row := q.db.QueryRow(ctx, CreateEmployeeMCPConfig,
		arg.EmployeeID,
		arg.McpCatalogID,
		arg.ConnectionConfig,
		arg.IsEnabled,
	)
	var i EmployeeMcpConfig
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.McpCatalogID,
		&i.Status,
		&i.ConnectionConfig,
		&i.CredentialsEncrypted,
		&i.SyncToken,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return i, err
}

const CreateMCPServer = `-- name: CreateMCPServer :one
INSERT INTO mcp_catalog (
    name,
    provider,
    version,
    description,
    connection_schema,
    capabilities,
    requires_credentials,
    is_approved,
    category_id,
    docker_image,
    config_template,
    required_env_vars
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars
`

type CreateMCPServerParams struct {
	Name                string          `json:"name"`
	Provider            string          `json:"provider"`
	Version             string          `json:"version"`
	Description         string          `json:"description"`
	ConnectionSchema    json.RawMessage `json:"connection_schema"`
	Capabilities        json.RawMessage `json:"capabilities"`
	RequiresCredentials bool            `json:"requires_credentials"`
	IsApproved          bool            `json:"is_approved"`
	CategoryID          pgtype.UUID     `json:"category_id"`
	DockerImage         *string         `json:"docker_image"`
	ConfigTemplate      []byte          `json:"config_template"`
	RequiredEnvVars     []byte          `json:"required_env_vars"`
}

func (q *Queries) CreateMCPServer(ctx context.Context, arg CreateMCPServerParams) (McpCatalog, error) {
	row := q.db.QueryRow(ctx, CreateMCPServer,
		arg.Name,
		arg.Provider,
		arg.Version,
		arg.Description,
		arg.ConnectionSchema,
		arg.Capabilities,
		arg.RequiresCredentials,
		arg.IsApproved,
		arg.CategoryID,
		arg.DockerImage,
		arg.ConfigTemplate,
		arg.RequiredEnvVars,
	)
	var i McpCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Version,
		&i.Description,
		&i.ConnectionSchema,
		&i.Capabilities,
		&i.RequiresCredentials,
		&i.IsApproved,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DockerImage,
		&i.ConfigTemplate,
		&i.RequiredEnvVars,
	)
	return i, err
}

const DeleteEmployeeMCPConfig = `-- name: DeleteEmployeeMCPConfig :exec
DELETE FROM employee_mcp_configs
WHERE employee_id = $1 AND mcp_catalog_id = $2
`

type DeleteEmployeeMCPConfigParams struct {
	EmployeeID   uuid.UUID `json:"employee_id"`
	McpCatalogID uuid.UUID `json:"mcp_catalog_id"`
}

func (q *Queries) DeleteEmployeeMCPConfig(ctx context.Context, arg DeleteEmployeeMCPConfigParams) error {
	_, err := q.db.Exec(ctx, DeleteEmployeeMCPConfig, arg.EmployeeID, arg.McpCatalogID)
	return err
}

const DeleteMCPServer = `-- name: DeleteMCPServer :exec
DELETE FROM mcp_catalog
WHERE id = $1
`

func (q *Queries) DeleteMCPServer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteMCPServer, id)
	return err
}

const DisapproveMCPServer = `-- name: DisapproveMCPServer :exec
UPDATE mcp_catalog
SET is_approved = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DisapproveMCPServer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DisapproveMCPServer, id)
	return err
}

const GetEmployeeMCPConfig = `-- name: GetEmployeeMCPConfig :one
SELECT
    mc.id, mc.name, mc.provider, mc.version, mc.description, mc.connection_schema, mc.capabilities, mc.requires_credentials, mc.is_approved, mc.category_id, mc.created_at, mc.updated_at, mc.docker_image, mc.config_template, mc.required_env_vars,
    emc.connection_config,
    emc.is_enabled,
    emc.created_at as configured_at
FROM mcp_catalog mc
JOIN employee_mcp_configs emc ON emc.mcp_catalog_id = mc.id
WHERE emc.employee_id = $1 AND emc.mcp_catalog_id = $2
`

type GetEmployeeMCPConfigParams struct {
	EmployeeID   uuid.UUID `json:"employee_id"`
	McpCatalogID uuid.UUID `json:"mcp_catalog_id"`
}

type GetEmployeeMCPConfigRow struct {
	ID                  uuid.UUID        `json:"id"`
	Name                string           `json:"name"`
	Provider            string           `json:"provider"`
	Version             string           `json:"version"`
	Description         string           `json:"description"`
	ConnectionSchema    json.RawMessage  `json:"connection_schema"`
	Capabilities        json.RawMessage  `json:"capabilities"`
	RequiresCredentials bool             `json:"requires_credentials"`
	IsApproved          bool             `json:"is_approved"`
	CategoryID          pgtype.UUID      `json:"category_id"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	DockerImage         *string          `json:"docker_image"`
	ConfigTemplate      []byte           `json:"config_template"`
	RequiredEnvVars     []byte           `json:"required_env_vars"`
	ConnectionConfig    json.RawMessage  `json:"connection_config"`
	IsEnabled           *bool            `json:"is_enabled"`
	ConfiguredAt        pgtype.Timestamp `json:"configured_at"`
}

func (q *Queries) GetEmployeeMCPConfig(ctx context.Context, arg GetEmployeeMCPConfigParams) (GetEmployeeMCPConfigRow, error) {
	row := q.db.QueryRow(ctx, GetEmployeeMCPConfig, arg.EmployeeID, arg.McpCatalogID)
	var i GetEmployeeMCPConfigRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Version,
		&i.Description,
		&i.ConnectionSchema,
		&i.Capabilities,
		&i.RequiresCredentials,
		&i.IsApproved,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DockerImage,
		&i.ConfigTemplate,
		&i.RequiredEnvVars,
		&i.ConnectionConfig,
		&i.IsEnabled,
		&i.ConfiguredAt,
	)
	return i, err
}

const GetMCPServer = `-- name: GetMCPServer :one
SELECT id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars FROM mcp_catalog
WHERE id = $1
`

func (q *Queries) GetMCPServer(ctx context.Context, id uuid.UUID) (McpCatalog, error) {
	row := q.db.QueryRow(ctx, GetMCPServer, id)
	var i McpCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Version,
		&i.Description,
		&i.ConnectionSchema,
		&i.Capabilities,
		&i.RequiresCredentials,
		&i.IsApproved,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DockerImage,
		&i.ConfigTemplate,
		&i.RequiredEnvVars,
	)
	return i, err
}

const GetMCPServerByName = `-- name: GetMCPServerByName :one
SELECT id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars FROM mcp_catalog
WHERE name = $1
`

func (q *Queries) GetMCPServerByName(ctx context.Context, name string) (McpCatalog, error) {
	row := q.db.QueryRow(ctx, GetMCPServerByName, name)
	var i McpCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Version,
		&i.Description,
		&i.ConnectionSchema,
		&i.Capabilities,
		&i.RequiresCredentials,
		&i.IsApproved,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DockerImage,
		&i.ConfigTemplate,
		&i.RequiredEnvVars,
	)
	return i, err
}

const GetMCPUsageCount = `-- name: GetMCPUsageCount :one
SELECT COUNT(*)
FROM employee_mcp_configs
WHERE mcp_catalog_id = $1 AND is_enabled = true
`

func (q *Queries) GetMCPUsageCount(ctx context.Context, mcpCatalogID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, GetMCPUsageCount, mcpCatalogID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ListAllMCPServers = `-- name: ListAllMCPServers :many
SELECT id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars FROM mcp_catalog
ORDER BY provider, name
`

func (q *Queries) ListAllMCPServers(ctx context.Context) ([]McpCatalog, error) {
	rows, err := q.db.Query(ctx, ListAllMCPServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpCatalog{}
	for rows.Next() {
		var i McpCatalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Provider,
			&i.Version,
			&i.Description,
			&i.ConnectionSchema,
			&i.Capabilities,
			&i.RequiresCredentials,
			&i.IsApproved,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DockerImage,
			&i.ConfigTemplate,
			&i.RequiredEnvVars,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEmployeeMCPConfigs = `-- name: ListEmployeeMCPConfigs :many

SELECT
    mc.id,
    mc.name,
    mc.provider,
    mc.version,
    mc.description,
    mc.docker_image,
    mc.config_template,
    mc.required_env_vars,
    emc.connection_config,
    emc.is_enabled,
    emc.created_at
FROM mcp_catalog mc
JOIN employee_mcp_configs emc ON emc.mcp_catalog_id = mc.id
WHERE emc.employee_id = $1
ORDER BY mc.provider, mc.name
`

type ListEmployeeMCPConfigsRow struct {
	ID               uuid.UUID        `json:"id"`
	Name             string           `json:"name"`
	Provider         string           `json:"provider"`
	Version          string           `json:"version"`
	Description      string           `json:"description"`
	DockerImage      *string          `json:"docker_image"`
	ConfigTemplate   []byte           `json:"config_template"`
	RequiredEnvVars  []byte           `json:"required_env_vars"`
	ConnectionConfig json.RawMessage  `json:"connection_config"`
	IsEnabled        *bool            `json:"is_enabled"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

// ============================================================================
// Employee MCP Configuration Queries
// ============================================================================
func (q *Queries) ListEmployeeMCPConfigs(ctx context.Context, employeeID uuid.UUID) ([]ListEmployeeMCPConfigsRow, error) {
	rows, err := q.db.Query(ctx, ListEmployeeMCPConfigs, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeeMCPConfigsRow{}
	for rows.Next() {
		var i ListEmployeeMCPConfigsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Provider,
			&i.Version,
			&i.Description,
			&i.DockerImage,
			&i.ConfigTemplate,
			&i.RequiredEnvVars,
			&i.ConnectionConfig,
			&i.IsEnabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMCPServers = `-- name: ListMCPServers :many

SELECT id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars FROM mcp_catalog
WHERE is_approved = true
ORDER BY provider, name
`

// ============================================================================
// MCP Catalog Queries
// ============================================================================
func (q *Queries) ListMCPServers(ctx context.Context) ([]McpCatalog, error) {
	rows, err := q.db.Query(ctx, ListMCPServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpCatalog{}
	for rows.Next() {
		var i McpCatalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Provider,
			&i.Version,
			&i.Description,
			&i.ConnectionSchema,
			&i.Capabilities,
			&i.RequiresCredentials,
			&i.IsApproved,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DockerImage,
			&i.ConfigTemplate,
			&i.RequiredEnvVars,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEmployeeMCPConfig = `-- name: UpdateEmployeeMCPConfig :one
UPDATE employee_mcp_configs
SET
    connection_config = COALESCE($1, connection_config),
    is_enabled = COALESCE($2, is_enabled),
    updated_at = NOW()
WHERE employee_id = $3 AND mcp_catalog_id = $4
RETURNING id, employee_id, mcp_catalog_id, status, connection_config, credentials_encrypted, sync_token, last_sync_at, created_at, updated_at, is_enabled
`

type UpdateEmployeeMCPConfigParams struct {
	ConnectionConfig []byte    `json:"connection_config"`
	IsEnabled        *bool     `json:"is_enabled"`
	EmployeeID       uuid.UUID `json:"employee_id"`
	McpCatalogID     uuid.UUID `json:"mcp_catalog_id"`
}

func (q *Queries) UpdateEmployeeMCPConfig(ctx context.Context, arg UpdateEmployeeMCPConfigParams) (EmployeeMcpConfig, error) {
	row := q.db.QueryRow(ctx, UpdateEmployeeMCPConfig,
		arg.ConnectionConfig,
		arg.IsEnabled,
		arg.EmployeeID,
		arg.McpCatalogID,
	)
	var i EmployeeMcpConfig
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.McpCatalogID,
		&i.Status,
		&i.ConnectionConfig,
		&i.CredentialsEncrypted,
		&i.SyncToken,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return i, err
}

const UpdateMCPServer = `-- name: UpdateMCPServer :one
UPDATE mcp_catalog
SET
    provider = COALESCE($1, provider),
    version = COALESCE($2, version),
    description = COALESCE($3, description),
    connection_schema = COALESCE($4, connection_schema),
    capabilities = COALESCE($5, capabilities),
    requires_credentials = COALESCE($6, requires_credentials),
    is_approved = COALESCE($7, is_approved),
    category_id = COALESCE($8, category_id),
    docker_image = COALESCE($9, docker_image),
    config_template = COALESCE($10, config_template),
    required_env_vars = COALESCE($11, required_env_vars),
    updated_at = NOW()
WHERE id = $12
RETURNING id, name, provider, version, description, connection_schema, capabilities, requires_credentials, is_approved, category_id, created_at, updated_at, docker_image, config_template, required_env_vars
`

type UpdateMCPServerParams struct {
	Provider            *string     `json:"provider"`
	Version             *string     `json:"version"`
	Description         *string     `json:"description"`
	ConnectionSchema    []byte      `json:"connection_schema"`
	Capabilities        []byte      `json:"capabilities"`
	RequiresCredentials *bool       `json:"requires_credentials"`
	IsApproved          *bool       `json:"is_approved"`
	CategoryID          pgtype.UUID `json:"category_id"`
	DockerImage         *string     `json:"docker_image"`
	ConfigTemplate      []byte      `json:"config_template"`
	RequiredEnvVars     []byte      `json:"required_env_vars"`
	ID                  uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateMCPServer(ctx context.Context, arg UpdateMCPServerParams) (McpCatalog, error) {
	row := q.db.QueryRow(ctx, UpdateMCPServer,
		arg.Provider,
		arg.Version,
		arg.Description,
		arg.ConnectionSchema,
		arg.Capabilities,
		arg.RequiresCredentials,
		arg.IsApproved,
		arg.CategoryID,
		arg.DockerImage,
		arg.ConfigTemplate,
		arg.RequiredEnvVars,
		arg.ID,
	)
	var i McpCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Version,
		&i.Description,
		&i.ConnectionSchema,
		&i.Capabilities,
		&i.RequiresCredentials,
		&i.IsApproved,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DockerImage,
		&i.ConfigTemplate,
		&i.RequiredEnvVars,
	)
	return i, err
}
